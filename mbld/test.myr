use std

use "build"
use "opts"
use "types"
use "util"
use "subtest"

use "config"

pkg bld =
	const test	: (b : build# -> bool)
;;

const test = {b
	var failed, ok
	var tests

	if !buildtarg(b, "test")
		std.exit(1)
	;;
	tests = std.htgetv(b.deps.targs, "test", [][:])
	ok = true
	failed = [][:]
	for t in tests
		if !runtest(b, t, &failed)
			ok = false
		;;
	;;
	std.chdir(b.basedir)

	if tests.len == 0
		-> true
	;;

	printfailed(failed)
	if ok
		mbldput("TESTS PASSED\n")
	else
		mbldput("TESTS FAILED\n")
	;;
	std.slfree(failed)
	-> ok
}

const printfailed = {failed
	if failed.len > 0
		mbldput("FAILURES: {}\n", failed.len)
		for t in failed
			mbldput("\t{}\n", t)
		;;
	;;
}

const runtest = {b, n, failed
	var dir, res, log, logfd
	var sub

	dir = std.pathcat(b.basedir, n.wdir)
	mbldput("run {}:\t", n.lbl)
	std.chdir(dir)
	match std.spork(n.cmd)
	| `std.Err m:
		std.fatal("\nunable to run test: {}\n", m)
	| `std.Ok (pid, infd, outfd):
		log = std.strcat(std.basename(n.lbl), ".log")
		logfd = std.try(std.openmode(log, std.Owronly | std.Ocreat, 0o644))
		sub = showsub(b, n.lbl, outfd, logfd, failed)
		std.slfree(log)
		std.close(infd)
		std.close(outfd)

		res = false
		match std.wait(pid)
		| `std.Waiterror:	mbldput("FUCK pid {}\n", pid)
		| `std.Wfailure:	mbldput("FAIL\n")
		| `std.Wsignalled:	mbldput("CRASH\n")
		| `std.Wsuccess:
			res = true
			/* if we have subtests, we've already printed the output */
			match sub
			| `std.Some r:	res = r
			| `std.None:	mbldput("PASS\n")
			;;
		;;
		if !res
			std.slpush(failed, n.lbl)
		;;
	;;
	std.slfree(dir)
	-> res
}

