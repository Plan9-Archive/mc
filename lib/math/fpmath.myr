use std

pkg math =
	trait fpmath @f =

		/* fpmath-fma-impl */
		fma : (x : @f, y : @f, z : @f -> @f)

		/* fpmath-trunc-impl */
		trunc : (f : @f -> @f)
		ceil  : (f : @f -> @f)
		floor : (f : @f -> @f)

		/* fpmath-sum-impl */
		kahan_sum : (a : @f[:] -> @f)
		priest_sum : (a : @f[:] -> @f)
	;;

	impl std.equatable flt32
	impl std.equatable flt64
	impl fpmath flt32
	impl fpmath flt64
;;

/*
   We consider two floating-point numbers equal if their bits are
   equal. This does not treat NaNs specially: two distinct NaNs may
   compare equal, or they may compare distinct (if they arise from
   different bit patterns).

   Additionally, +0.0 and -0.0 compare differently.
 */
impl std.equatable flt32 =
	eq = {a : flt32, b : flt32; -> std.flt32bits(a) == std.flt32bits(b)}
;;

impl std.equatable flt64 =
	eq = {a : flt64, b : flt64; -> std.flt64bits(a) == std.flt64bits(b)}
;;

impl fpmath flt32 =
	fma = {x, y, z; -> fma32(x, y, z)}

	trunc = {f; -> trunc32(f)}
	floor = {f; -> floor32(f)}
	ceil  = {f; -> ceil32(f)}

	kahan_sum = {l; -> kahan_sum32(l) }
	priest_sum = {l; -> priest_sum32(l) }
;;

impl fpmath flt64 =
	fma = {x, y, z; -> fma64(x, y, z)}

	trunc = {f; -> trunc64(f)}
	floor = {f; -> floor64(f)}
	ceil  = {f; -> ceil64(f)}

	kahan_sum = {l; -> kahan_sum64(l) }
	priest_sum = {l; -> priest_sum64(l) }
;;

extern const fma32 : (x : flt32, y : flt32, z : flt32 -> flt32)
extern const fma64 : (x : flt64, y : flt64, z : flt64 -> flt64)

extern const trunc32 : (f : flt32 -> flt32)
extern const floor32 : (f : flt32 -> flt32)
extern const ceil32  : (f : flt32 -> flt32)

extern const trunc64 : (f : flt64 -> flt64)
extern const floor64 : (f : flt64 -> flt64)
extern const ceil64  : (f : flt64 -> flt64)

extern const kahan_sum32 : (l : flt32[:] -> flt32)
extern const priest_sum32 : (l : flt32[:] -> flt32)

extern const kahan_sum64 : (l : flt64[:] -> flt64)
extern const priest_sum64 : (l : flt64[:] -> flt64)
