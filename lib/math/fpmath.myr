use std

pkg math =
	trait fpmath @f =

		/* fpmath-trunc-impl */
		trunc : (f : @f -> @f)
		ceil  : (f : @f -> @f)
		floor : (f : @f -> @f)

		/* compute (s, t) with s = round-nearest(a+b), s + t = a + b */
//		fast2sum : (a : @f, b : @f -> (@f, @f))
	;;

	impl std.equatable flt32
	impl std.equatable flt64
	impl fpmath flt32
	impl fpmath flt64
;;

/*
   We consider two floating-point numbers equal if their bits are
   equal. This does not treat NaNs specially: two distinct NaNs may
   compare equal, or they may compare distinct (if they arise from
   different bit patterns).

   Additionally, +0.0 and -0.0 compare differently.
 */
impl std.equatable flt32 =
	eq = {a : flt32, b : flt32; -> std.flt32bits(a) == std.flt32bits(b)}
;;

impl std.equatable flt64 =
	eq = {a : flt64, b : flt64; -> std.flt64bits(a) == std.flt64bits(b)}
;;

impl fpmath flt32 =
	trunc = {f; -> trunc32(f)}
	floor = {f; -> floor32(f)}
	ceil  = {f; -> ceil32(f)}
;;

impl fpmath flt64 =
	trunc = {f; -> trunc64(f)}
	floor = {f; -> floor64(f)}
	ceil  = {f; -> ceil64(f)}
;;

extern const trunc32 : (f : flt32 -> flt32)
extern const floor32 : (f : flt32 -> flt32)
extern const ceil32  : (f : flt32 -> flt32)
extern const trunc64 : (f : flt64 -> flt64)
extern const floor64 : (f : flt64 -> flt64)
extern const ceil64  : (f : flt64 -> flt64)
